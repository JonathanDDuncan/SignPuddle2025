---
applyTo: '**'
---
Coding standards, domain knowledge, and preferences that AI should follow.

## Technology Context Files üìö
**IMPORTANT**:  You can use Context7 MCP for technology-specific guidance, patterns, and best practices, always reference:

### Quick Technology Reference 

**Rule**: Check relevant context files BEFORE implementing any technology-specific features!

### SignPuddle Database Technology Stack üóÑÔ∏è
- **Database ORM**: Entity Framework Core 9.0.5
- **Primary Database**: Azure CosmosDB (NoSQL for all data storage)
- **Testing Database**: In-Memory Database (EF Core InMemory provider)
- **API Framework**: ASP.NET Core 9.0 Web API
- **Authentication**: JWT Bearer Authentication (9.0.5)
- **Test Framework**: xUnit 2.9.0 with 97+ comprehensive tests
- **Architecture**: Repository pattern with dependency injection

### CosmosDB-Specific Patterns üóÑÔ∏è

#### Partition Key Strategies
- **Signs**: Partitioned by `DictionaryId` for efficient dictionary-based queries
- **SpmlDocuments**: Partitioned by `PartitionKey` (derived from SPML type: "sgn", "ase", etc.)
- **Dictionaries**: No specific partition key (small dataset)
- **Users**: No specific partition key (small dataset)

#### Container Configuration
```csharp
// Signs - partition by dictionary for related queries
modelBuilder.Entity<Sign>()
    .ToContainer("Signs")
    .HasPartitionKey(s => s.DictionaryId)
    .HasNoDiscriminator();

// SPML Documents - partition by type for efficient filtering
modelBuilder.Entity<SpmlDocumentEntity>()
    .ToContainer("SpmlDocuments")
    .HasPartitionKey(e => e.PartitionKey)
    .HasNoDiscriminator();

// Owned entities for complex nested data
modelBuilder.Entity<SpmlDocumentEntity>()
    .OwnsOne(e => e.SpmlDocument);
```

#### Query Optimization Patterns
- **Cross-partition queries**: Minimize by designing queries within partition boundaries
- **Point reads**: Use ID + partition key for fastest access
- **Client evaluation**: For complex owned entity queries, fetch to memory then filter
- **Async operations**: All database operations use async/await patterns

#### Performance Settings
```csharp
options.UseCosmos(
    accountEndpoint: endpoint,
    accountKey: key,
    databaseName: dbName,
    cosmosOptionsAction: options =>
    {
        options.ConnectionMode(ConnectionMode.Direct);      // Direct TCP connection
        options.MaxRequestsPerTcpConnection(20);           // Connection pooling
        options.MaxTcpConnectionsPerEndpoint(32);          // Endpoint connections
    }
);
```

#### Consistency Levels
- **Default**: Session consistency (balanced performance/consistency)
- **Read operations**: Eventual consistency acceptable for most queries
- **Write operations**: Strong consistency for critical operations
- **Cross-region**: Not currently configured (single region deployment)

#### Indexing Strategy
- **Automatic indexing**: CosmosDB handles most indexing automatically
- **Custom indexes**: Added for common query patterns (DocumentType, OwnerId)
- **Composite indexes**: Consider for multi-property filter queries
- **Exclude unused paths**: Optimize for write performance where appropriate

---

# AI-Assisted Vibe Coding Development Guide
---

## üéØ Core Mission

You are an AI coding assistant following **vibe coding principles** with **micro-unit development**. Build high-quality software through natural language communication, focusing on atomic functions (max 15 lines) that are independently testable and composable.

---

## üìú The TFCDC Framework

**T - Thinking** (4 Levels):
- **Logical**: What are we building?
- **Analytical**: How does it work?
- **Computational**: How do we fit logic into configurations?
- **Procedural**: What strategies optimize performance?

**F - Frameworks**: Always specify exact tech stack
**C - Checkpoints**: Use version control at every micro-function
**D - Debugging**: Systematic isolation to specific micro-functions
**C - Context**: Provide maximum context for all requests

---

## üèóÔ∏è 3-Phase Planning (Before Any Code)

### Phase 1: Architecture & Features
Create comprehensive PRD with:
- MVP user flow
- Feature breakdown with tech requirements
- System architecture diagram
- Clarifying questions

### Phase 2: Screen Design & States
Define 3-5 states per screen:
- Loading, error, empty, populated, interactive states
- Motion choreography and responsive feedback

### Phase 3: Technical Specifications
- File system structure
- API endpoints and database schema
- Micro-function breakdown per feature
- Security considerations and edge cases

---

## üî¨ Micro-Unit Development Protocol

### Hard Rules
- **Maximum 15 lines of logic per function**
- **One responsibility per function**
- **Unit test required before integration**
- **Validation checkpoint after each function**

### Implementation Sequence
1. **Atomic Breakdown**: List micro-functions needed (no code)
2. **User Confirmation**: Get approval for breakdown
3. **Single Micro-Function**: Implement one function + tests
4. **Validation**: Show tests passing with real data
5. **Composition**: Combine tested functions (max 5 lines coordination)
6. **Integration Testing**: Realistic end-to-end scenarios

---

## üí¨ 6-Component Prompt Framework

Every request must include:

**1. ROLE**: Expert in [specific technology] following micro-unit principles
**2. TASK**: Specific objective (implement one micro-function, debug specific issue, etc.)
**3. INPUT**: Exact specifications, error messages, or requirements
**4. OUTPUT**: Detailed format (function + tests, composition, debugging analysis)
**5. CONSTRAINTS**: What NOT to do (don't write multiple functions, don't skip tests, etc.)
**6. CAPABILITIES**: Available tools, project context, existing micro-function library

---

## üß™ Testing Strategy

### Micro-Function Tests (Required)
- **3 minimum test cases**: Happy path, edge case, error condition
- **Isolation testing**: No external dependencies
- **Real data demonstration**: Show function working with actual inputs

### Composition Tests
- **Integration scenarios**: Realistic user workflows
- **Error propagation**: Verify errors handled across function boundaries
- **Performance validation**: Ensure composed functions meet requirements

---

## üö® Debugging Protocol

When issues arise:
1. **Isolate**: Identify specific failing micro-function
2. **Test Independence**: Verify function works alone
3. **Minimal Fix**: Modify only the problematic function
4. **Validate**: Test fix in isolation then integration
5. **Document**: Record solution for future reference

---

## üìã Essential Prompt Templates

### Project Initialization
```
ROLE: Senior [TECH_STACK] developer expert in micro-unit architecture
TASK: Create PRD and technical architecture for [PROJECT_CONCEPT]
INPUT: [Brief app description, target users, key features]
OUTPUT: Complete PRD with micro-function breakdown and milestone plan
CONSTRAINTS: Design for MVP first, plan for 10 to 500k+ user scalability
CAPABILITIES: Modern frameworks, scalable architecture, AI-assisted patterns
```

### Micro-Function Implementation
```
ROLE: [LANGUAGE] expert following micro-unit development
TASK: Implement ONLY [FUNCTION_NAME] micro-function
INPUT: [Single responsibility description, parameters, expected output]
OUTPUT: Function (max 15 lines) + unit tests + real data demo
CONSTRAINTS: One function only, no integration, must pass all tests
CAPABILITIES: Project patterns, testing framework, existing micro-functions

VALIDATION REQUIRED:
‚úÖ Function compiles and passes tests
‚úÖ Works with real test data  
‚úÖ Single responsibility confirmed
‚úÖ Wait for approval before next function
```

### Composition Function
```
ROLE: Integration expert for micro-function composition
TASK: Combine [FUNCTION_A] + [FUNCTION_B] + [FUNCTION_C]
INPUT: Previously tested micro-functions
OUTPUT: Composition (max 5 lines) + integration tests + realistic demo
CONSTRAINTS: Coordination only, no new business logic
CAPABILITIES: All tested micro-functions, integration testing tools
```

### Debugging Session
```
ROLE: Debugging specialist for micro-function architectures
TASK: Fix issue in [SPECIFIC_COMPONENT]
INPUT: Error message: [FULL_ERROR], current vs expected behavior
OUTPUT: Root cause analysis + minimal fix + validation
CONSTRAINTS: Fix only failing micro-function, maintain existing functionality
CAPABILITIES: Complete codebase, debugging tools, version control history
```

### SignPuddle Database-Specific Templates

#### SPML Import Function
```
ROLE: Entity Framework Core expert specializing in SPML data migration
TASK: Implement [SPML_FUNCTION_NAME] for legacy data import
INPUT: SPML XML structure, target entity mapping, validation requirements
OUTPUT: Micro-function (max 15 lines) + xUnit tests + real SPML data demo
CONSTRAINTS: Preserve 100% data integrity, handle malformed XML gracefully
CAPABILITIES: SpmlImportService, SpmlRepository, CosmosDB integration

VALIDATION REQUIRED:
‚úÖ SPML XML parsing works with test files
‚úÖ Data integrity preserved (timestamps, user attribution)
‚úÖ Error handling for invalid/incomplete data
‚úÖ Performance acceptable for large files
```

#### Repository Method Implementation
```
ROLE: Repository pattern expert for SignPuddle database architecture
TASK: Implement [REPOSITORY_METHOD] in [ENTITY]Repository
INPUT: Entity type, query requirements, expected return type
OUTPUT: Repository method (max 15 lines) + integration tests + real data
CONSTRAINTS: Follow existing repository patterns, async/await required
CAPABILITIES: ApplicationDbContext, existing repository interfaces, EF Core

VALIDATION REQUIRED:  
‚úÖ Method follows repository pattern consistently
‚úÖ Async operations with proper error handling
‚úÖ Integration tests with real database
‚úÖ Null reference safety with C# 12 nullable types
```

#### Database Entity Enhancement
```
ROLE: Entity Framework Core domain modeling expert
TASK: Enhance [ENTITY_NAME] entity with [NEW_PROPERTY/RELATIONSHIP]
INPUT: Entity requirements, relationship type, validation rules
OUTPUT: Entity update + migration + tests + relationship validation
CONSTRAINTS: Maintain existing relationships, follow naming conventions
CAPABILITIES: EF Core 9.0.5, CosmosDB, existing entity relationships

VALIDATION REQUIRED:
‚úÖ Entity relationships properly configured
‚úÖ Database migration generated and tested
‚úÖ Existing data compatibility maintained
‚úÖ Repository methods updated accordingly
```

#### Performance Optimization Function
```
ROLE: Database performance optimization specialist for Entity Framework
TASK: Optimize [QUERY/OPERATION] performance in [COMPONENT]
INPUT: Current implementation, performance requirements, bottleneck analysis
OUTPUT: Optimized function + performance tests + benchmark comparison
CONSTRAINTS: Maintain functionality, improve specific performance metric
CAPABILITIES: EF Core query optimization, async patterns, performance testing

VALIDATION REQUIRED:
‚úÖ Performance improvement measurable and documented
‚úÖ Functionality unchanged (all existing tests pass)
‚úÖ Memory usage within acceptable limits
‚úÖ Concurrent operation support maintained
```

#### FSW Validation Function
```
ROLE: SignWriting domain expert specializing in FSW format validation
TASK: Implement [FSW_VALIDATION_FUNCTION] for sign language data validation
INPUT: FSW string, validation requirements, symbol category constraints
OUTPUT: Micro-function (max 15 lines) + unit tests + real FSW data demo
CONSTRAINTS: Strict adherence to ISWA 2010 standards, handle malformed FSW gracefully
CAPABILITIES: FSW regex patterns, coordinate validation, symbol categorization

VALIDATION REQUIRED:
‚úÖ FSW validation follows ISWA 2010 specifications
‚úÖ Coordinate range validation (250-749)
‚úÖ Symbol format validation (S[base][fill][rotation])
‚úÖ Complete sign structure validation (temporal + spatial)
```

#### SignWriting Format Conversion
```
ROLE: SignWriting format conversion specialist
TASK: Implement [FORMAT_CONVERSION] between FSW/SWU/SPML formats
INPUT: Source format string, target format, conversion requirements
OUTPUT: Conversion function (max 15 lines) + bidirectional tests + format validation
CONSTRAINTS: Preserve semantic meaning, maintain coordinate precision
CAPABILITIES: FSW/SWU conversion patterns, SPML XML processing, character mapping

VALIDATION REQUIRED:
‚úÖ Bidirectional conversion accuracy (FSW ‚Üî SWU)
‚úÖ SPML DTD compliance for XML operations
‚úÖ Coordinate precision preservation
‚úÖ Symbol integrity across format conversions
```

#### SPML Legacy Migration Function
```
ROLE: SPML import specialist for legacy SignPuddle data migration
TASK: Implement [SPML_MIGRATION_FUNCTION] for legacy puddle import
INPUT: SPML XML structure, target database schema, data integrity requirements
OUTPUT: Migration function (max 15 lines) + integration tests + data validation
CONSTRAINTS: 100% data preservation, handle incomplete/malformed SPML
CAPABILITIES: SPML DTD 1.6 schema, Unix timestamp conversion, user attribution

VALIDATION REQUIRED:
‚úÖ SPML DTD 1.6 compliance validation
‚úÖ Unix timestamp conversion accuracy
‚úÖ User attribution preservation
‚úÖ FSW extraction from SPML terms
‚úÖ Entry relationship preservation (prev/next links)
```

---

## ‚úÖ Quality Gates

### Per Micro-Function
- [ ] Single responsibility (describable in one sentence)
- [ ] Under 15 lines of logic
- [ ] 3+ passing unit tests
- [ ] Works in isolation
- [ ] Clear, intention-revealing name

### Per Composition
- [ ] Coordinates without adding business logic
- [ ] Integration tests pass
- [ ] Error handling across boundaries
- [ ] Performance meets requirements

### Per Feature
- [ ] All micro-functions tested
- [ ] End-to-end scenarios work
- [ ] Meets PRD requirements
- [ ] Maintainable and debuggable

### SignPuddle Database Quality Gates

#### Per Database Entity
- [ ] Follows Entity Framework conventions (PascalCase, proper relationships)
- [ ] Nullable reference types properly configured (C# 12)
- [ ] Primary key and foreign key relationships defined
- [ ] Repository interface and implementation created
- [ ] Unit tests for all CRUD operations with real data

#### Per Repository Method
- [ ] Async/await pattern consistently applied
- [ ] Proper null checking and argument validation
- [ ] Returns appropriate types (Task<T>, Task<List<T>>, etc.)
- [ ] Error handling with meaningful exception messages
- [ ] Integration tests with ApplicationDbContext

#### Per SPML Operation
- [ ] Preserves original data integrity (timestamps, user attribution)
- [ ] Handles malformed or incomplete XML gracefully
- [ ] Performance acceptable for production SPML file sizes
- [ ] Export functionality maintains backward compatibility
- [ ] Comprehensive error logging for debugging

#### Per API Controller Method
- [ ] Proper dependency injection of repositories/services
- [ ] HTTP status codes correctly applied (200, 400, 404, 500)
- [ ] Request/response models properly defined
- [ ] Authentication/authorization requirements enforced
- [ ] Swagger documentation complete and accurate

### SignWriting Domain Quality Gates

#### Per FSW Validation Function
- [ ] Follows ISWA 2010 symbol categorization standards
- [ ] Validates coordinate ranges (250-749 for X and Y)
- [ ] Distinguishes temporal prefix from spatial signbox
- [ ] Provides meaningful error messages for invalid FSW

#### Per Format Conversion Function
- [ ] Maintains semantic equivalence across format conversions
- [ ] Handles bidirectional conversion accurately
- [ ] Validates input format before conversion
- [ ] Returns appropriate error for unsupported format combinations

#### Per SPML Operation
- [ ] Complies with SPML DTD 1.6 schema requirements
- [ ] Preserves element order: (term*,text*,png?,svg?,src*,entry*)
- [ ] Handles Unix timestamp conversion to UTC DateTime
- [ ] Extracts FSW notation from term elements correctly
- [ ] Maintains entry relationships (prev/next navigation)
- [ ] Preserves user attribution and creation timestamps

#### Per SignWriting Search Function
- [ ] Supports symbol-based search queries
- [ ] Handles partial FSW pattern matching
- [ ] Converts FSW to query format (Q prefix for spatial, QT for temporal)
- [ ] Indexes searchable symbols for performance
- [ ] Supports wildcard and category-based searches

#### Per Font Rendering Function
- [ ] Selects correct font based on symbol fill value
- [ ] Maps coordinates to canvas positioning accurately
- [ ] Handles symbol anchor points for proper alignment
- [ ] Supports all four SignWriting font types (Line, Fill, OneD, Null)
- [ ] Renders symbols within signbox boundaries

---

## üöÄ Session Workflow

### Pre-Development Checklist
- [ ] 95% confidence in requirements
- [ ] Framework/tech stack specified
- [ ] **Context files reviewed** for relevant technologies
- [ ] Version control ready
- [ ] PRD and architecture available
- [ ] Testing strategy confirmed

### Development Session
1. **Context Loading**: Project state, existing micro-functions, coding standards, **relevant technology context files**
2. **Atomic Planning**: Break feature into micro-functions (no code)
3. **Sequential Implementation**: One micro-function at a time with validation
4. **Progressive Composition**: Build up through tested combinations
5. **Integration Validation**: End-to-end testing with realistic scenarios

### Session Template
```  
VIBE CODING SESSION: SignPuddle Database Development
User: JonathanDDuncan
Date: 2025-06-21
Mode: [Planning/Implementation/Debugging]

TFCDC CHECK:
‚úÖ Thinking: Four levels applied
‚úÖ Frameworks: EF Core 9.0.5, ASP.NET Core 9.0, CosmosDB
‚úÖ Checkpoints: Version control ready, 89+ tests passing
‚úÖ Debugging: Systematic approach prepared  
‚úÖ Context: SignPuddle database architecture loaded

CURRENT STATE:
- Database Architecture: ‚úÖ Complete (5 entities, repositories, dual DB)
- SPML Integration: ‚úÖ Complete (import/export, legacy compatibility)
- Testing Framework: ‚úÖ Complete (89+ tests, real data validation)
- API Integration: ‚úÖ Complete (8 controllers, JWT auth, Swagger)

OBJECTIVE: [SPECIFIC_DATABASE_GOAL]
APPROACH: Micro-unit development with EF Core best practices

Ready to proceed with atomic breakdown and sequential implementation.
```

---

## üóÑÔ∏è SignPuddle Database Context

### Current Architecture Status
The SignPuddle database implementation is **production-ready** with comprehensive testing and modern architecture patterns. The system successfully migrates from legacy PHP/XML storage to Entity Framework Core while maintaining 100% backward compatibility.

### Key Success Metrics
- **89+ Tests Passing**: Comprehensive coverage across all layers
- **Database Architecture**: ‚úÖ Complete (5 entities, repositories, CosmosDB)  
- **Performance Validated**: Sub-2-second operations with concurrent support
- **Legacy Compatibility**: 100% SPML import/export functionality
- **Security Implemented**: JWT authentication with proper validation

### Next Development Areas
1. **Performance Optimization**: Query optimization and database indexing improvements
2. **Advanced Search**: Full-text search capabilities
3. **Monitoring**: Performance metrics and usage analytics
4. **Backup Strategy**: Automated backup and recovery procedures

---

**Key Principle**: Always confirm atomic breakdown before writing any code. Implement one micro-function at a time with complete testing. Build features through composition of verified atomic units while leveraging AI capabilities for exponential development velocity.

---

## SignWriting/Sign Language Domain Knowledge üìù

### SignWriting Technology Overview
SignWriting is a visual writing system for sign languages invented by Valerie Sutton in 1974. The SignPuddle system supports multiple encoding formats and legacy data migration.

### Core SignWriting Formats

#### 1. FSW (Formal SignWriting) - Primary Format
**Structure**: `[TemporalPrefix][SpatialSignbox]`
```
AS14c20S27106M518x529S14c20481x471S27106503x489
  ‚Üëtemporal prefix    ‚Üëspatial signbox
```

**Character Set**: Uses ASCII characters: `ABLMRS0123456789xabcdef`

**Key Components**:
- **Temporal Prefix**: `A` + optional lane markers + symbols with coordinates
- **Spatial Signbox**: Lane marker + dimensions + symbols with coordinates
- **Symbols**: `S[Base][Fill][Rotation]` format (e.g., `S1870a`)
- **Coordinates**: `[X]x[Y]` format with valid range 250-749

#### 2. SWU (SignWriting in Unicode) - Unicode Format
- Unicode-based representation maintaining FSW semantic structure
- Character mapping from ASCII to Unicode codepoints
- Bidirectional conversion with FSW

#### 3. Legacy Formats Supported
- **KSW (Kolumbus SignWriting)**: Legacy format support
- **BSW (Binary SignWriting)**: Compact binary format
- **CSW (Compact SignWriting)**: Space-efficient text format

### FSW Validation Rules

#### Symbol Validation
```csharp
// FSW symbol pattern: S + base(3 chars) + fill(1 char) + rotation(1 char)
public static readonly Regex FSW_SYMBOL = new(@"S[123][0-9a-f]{2}[0-5][0-9a-f]");

// Examples:
// S14c20 = S + 14c + 2 + 0 (valid)
// S38b0a = S + 38b + 0 + a (valid)
```

#### Coordinate Validation
```csharp
// Coordinate pattern: 3 digits + x + 3 digits
public static readonly Regex FSW_COORD = new(@"[0-9]{3}x[0-9]{3}");

// Valid coordinate range: 250-749 for both X and Y
public static bool IsValidCoordinate(int x, int y) =>
    x >= 250 && x <= 749 && y >= 250 && y <= 749;
```

#### Complete FSW Sign Validation
```csharp
// Full FSW sign pattern with temporal and spatial components
public static readonly Regex FSW_SIGN = new(
    @"(A([BLMRS]([0-9]{3}x[0-9]{3}))?" +
    @"(S[123][0-9a-f]{2}[0-5][0-9a-f][0-9]{3}x[0-9]{3})*)?)" +
    @"([BLMRS][0-9]{3}x[0-9]{3}" +
    @"(S[123][0-9a-f]{2}[0-5][0-9a-f][0-9]{3}x[0-9]{3})+)"
);
```

#### Symbol Categories (ISWA 2010)
```csharp
// Base symbol ranges for different categories
public static class SymbolCategories
{
    public const string HAND_SYMBOLS = "S100-S1f6"; // Hand shapes
    public const string MOVEMENT_SYMBOLS = "S200-S2ff"; // Movement arrows
    public const string DYNAMICS_SYMBOLS = "S300-S36f"; // Movement dynamics
    public const string HEAD_SYMBOLS = "S370-S37f"; // Head positions
    public const string FACE_SYMBOLS = "S380-S38f"; // Facial expressions
    public const string BODY_SYMBOLS = "S390-S3af"; // Body positions
    public const string PUNCTUATION = "S3b0-S3ff"; // Punctuation marks
}
```

### SPML (SignPuddle Markup Language) Format Details

#### SPML DTD Schema Structure (Version 1.6)
```xml
<!ELEMENT spml (term*,text*,png?,svg?,src*,entry*)>
<!ATTLIST spml 
    root CDATA #IMPLIED
    type CDATA #IMPLIED        <!-- Language type: "sgn", "ase", etc. -->
    puddle CDATA #IMPLIED      <!-- Dictionary/puddle ID -->
    uuid CDATA #IMPLIED        <!-- Unique identifier -->
    cdt CDATA #IMPLIED         <!-- Creation timestamp (Unix) -->
    mdt CDATA #IMPLIED         <!-- Modification timestamp (Unix) -->
    nextid CDATA #IMPLIED      <!-- Next available entry ID -->
>

<!ELEMENT entry (term*,text*,png?,svg?,video?,src*)>
<!ATTLIST entry 
    id CDATA #IMPLIED          <!-- Entry ID -->
    uuid CDATA #IMPLIED        <!-- Unique identifier -->
    prev CDATA #IMPLIED        <!-- Previous entry ID -->
    next CDATA #IMPLIED        <!-- Next entry ID -->
    cdt CDATA #IMPLIED         <!-- Creation timestamp (Unix) -->
    mdt CDATA #IMPLIED         <!-- Modification timestamp (Unix) -->
    usr CDATA #IMPLIED         <!-- User who created/modified -->
>
```

#### SPML Element Structure
```xml
<!-- Example SPML document structure -->
<spml type="sgn" puddle="4" uuid="..." cdt="1234567890" mdt="1234567890">
  <term>AS14c20S27106M518x529S14c20481x471S27106503x489</term>  <!-- FSW notation -->
  <text>hello</text>                                              <!-- Gloss/meaning -->
  <entry id="1" usr="admin" cdt="1234567890">
    <term>AS14c20S27106M518x529S14c20481x471S27106503x489</term>
    <text>hello</text>
    <video>video_url_here</video>
    <src>source_attribution</src>
  </entry>
</spml>
```

#### SPML Data Extraction Patterns
```csharp
// Extract FSW notation from SPML terms
public static string ExtractFSW(SpmlEntry entry)
{
    return entry.Terms?.FirstOrDefault(t => t.StartsWith("A") || t.StartsWith("M") || t.StartsWith("L")) ?? "";
}

// Extract gloss text (non-FSW terms)
public static string ExtractGloss(SpmlEntry entry)
{
    return entry.Terms?.FirstOrDefault(t => !IsFSWNotation(t)) ?? 
           entry.TextElements?.FirstOrDefault() ?? "";
}

// Unix timestamp conversion
public static DateTime ConvertUnixTimestamp(string unixTimestamp)
{
    if (long.TryParse(unixTimestamp, out long unix))
        return DateTimeOffset.FromUnixTimeSeconds(unix).UtcDateTime;
    return DateTime.UtcNow;
}
```

### Domain-Specific Validation Rules

#### Sign Language Linguistic Validation
```csharp
// Validate FSW represents a complete sign
public static bool IsCompleteSign(string fsw)
{
    // Must have both temporal (A prefix) and spatial (signbox) components
    return fsw.StartsWith("A") && 
           Regex.IsMatch(fsw, @"[BLMRS][0-9]{3}x[0-9]{3}") &&
           fsw.Contains("S"); // Must contain at least one symbol
}

// Validate spatial relationships in signbox
public static bool HasValidSpatialLayout(string fsw)
{
    var symbols = ExtractSymbolsWithCoordinates(fsw);
    var signboxDimensions = ExtractSignboxDimensions(fsw);
    
    // All symbols must be within signbox boundaries
    return symbols.All(s => IsWithinBounds(s.X, s.Y, signboxDimensions));
}

// Dictionary language type validation
public static bool IsValidLanguageType(string type)
{
    // Common sign language ISO codes
    var validTypes = new[] { "sgn", "ase", "bsl", "fsl", "dsl", "jsl" };
    return validTypes.Contains(type?.ToLower());
}
```

#### SPML Import Validation
```csharp
// Validate SPML document integrity
public static ValidationResult ValidateSpmlDocument(SpmlDocument document)
{
    var errors = new List<string>();
    
    // Required fields validation
    if (string.IsNullOrEmpty(document.Type))
        errors.Add("SPML type is required");
    
    if (document.PuddleId <= 0)
        errors.Add("Valid puddle ID is required");
    
    // Entry validation
    foreach (var entry in document.Entries ?? Enumerable.Empty<SpmlEntry>())
    {
        if (!entry.Terms?.Any() == true)
            errors.Add($"Entry {entry.Id} has no terms");
            
        // Validate FSW if present
        var fswTerm = entry.Terms?.FirstOrDefault(t => IsFSWNotation(t));
        if (fswTerm != null && !IsValidFSW(fswTerm))
            errors.Add($"Entry {entry.Id} has invalid FSW: {fswTerm}");
    }
    
    return new ValidationResult { IsValid = !errors.Any(), Errors = errors };
}
```